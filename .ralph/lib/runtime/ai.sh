#!/usr/bin/env bash
# AI engine helpers for Ralph orchestrator.
set -euo pipefail

# Run AI engine via hook or built-in fallback.
# Usage: run_ai_engine <prompt_file> <response_file> <engine_log> <step_index>
run_ai_engine() {
  local prompt_file="$1"
  local response_file="$2"
  local engine_log="$3"
  local i="$4"

  local ai_hook
  ai_hook=$(resolve_hook "ai")

  if [[ -n "${ai_hook}" ]]; then
    run_ai_hook "${ai_hook}" "${prompt_file}" "${response_file}" "${engine_log}" "${i}"
  else
    run_builtin_codex "${prompt_file}" "${response_file}" "${engine_log}" "${i}"
  fi
}

# Runs a command while showing progress with an indicator in interactive sessions.
run_ai_command_with_indicator() {
  local engine_log="$1"
  shift

  local rc=0
  if [[ -t 1 ]] && [[ "${DRY_RUN}" -ne 1 ]]; then
    set +e
    (
      "$@"
    ) >> "${engine_log}" 2>&1 &
    local pid=$!
    local elapsed=0
    local printed=0
    while kill -0 "${pid}" 2>/dev/null; do
      sleep 1
      elapsed=$((elapsed + 1))
      printf '\r%sworking...%s %ss' "${C_MAGENTA}" "${C_RESET}" "${elapsed}"
      printed=1
    done
    if [[ "${printed}" -eq 1 ]]; then
      printf '\r\033[K'
    fi
    wait "${pid}"
    rc=$?
    set -e
    return "${rc}"
  fi

  set +e
  (
    "$@"
  ) >> "${engine_log}" 2>&1
  rc=$?
  set -e
  return "${rc}"
}

# Run AI via hook.
run_ai_hook() {
  local hook_path="$1"
  local prompt_file="$2"
  local response_file="$3"
  local engine_log="$4"
  local i="$5"
  local hook_depth="${RALPH_HOOK_DEPTH:-0}"

  export RALPH_PROMPT_FILE="${prompt_file}"
  export RALPH_RESPONSE_FILE="${response_file}"
  export RALPH_ENGINE="${ACTIVE_ENGINE:-${RALPH_ENGINE:-codex}}"
  export RALPH_SESSION_ID="${session_id}"
  export RALPH_SESSION_DIR="${session_dir}"
  export RALPH_WORKSPACE="${ROOT}"
  export RALPH_MODEL="${ACTIVE_MODEL:-${MODEL:-}}"
  export RALPH_TIMEOUT="${TIMEOUT_SECONDS:-0}"
  export RALPH_DRY_RUN="${DRY_RUN}"
  export RALPH_VERBOSE="${VERBOSE}"
  export RALPH_STEP="${i}"
  export RALPH_WORKFLOW_TYPE="${RALPH_WORKFLOW_TYPE:-$(state_get_workflow_type || true)}"
  export RALPH_TASKS_FILE="${TASKS_JSON_PATH:-}"

  if [[ "${TIMEOUT_SECONDS}" -gt 0 ]] && [[ "${DRY_RUN}" -ne 1 ]]; then
    local rc=0
    run_ai_command_with_indicator "${engine_log}" \
      timeout "${TIMEOUT_SECONDS}" \
      env RALPH_HOOK_DEPTH="$((hook_depth + 1))" "${hook_path}" || rc=$?
    [[ "${rc}" -eq 124 ]] && echo "ai hook timed out after ${TIMEOUT_SECONDS}s" >&2
    return "${rc}"
  fi

  run_ai_command_with_indicator "${engine_log}" \
    env RALPH_HOOK_DEPTH="$((hook_depth + 1))" "${hook_path}"
}

# Built-in Codex execution (fallback when no AI hook is present).
run_builtin_codex() {
  local prompt_file="$1"
  local response_file="$2"
  local engine_log="$3"
  local i="$4"

  if [[ "${DRY_RUN}" -eq 1 ]]; then
    echo "[ai] Engine: mock (built-in dry-run)" >> "${engine_log}"
    echo "[ai] Prompt: ${prompt_file}" >> "${engine_log}"

    local prompt_preview timestamp
    prompt_preview=$(head -c 200 "${prompt_file}" | tr '\n' ' ')
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    cat > "${response_file}" <<EOF
##### Mock AI Response (Built-in)

**Generated:** ${timestamp}
**Engine:** mock (built-in fallback)
**Step:** ${i}/${total_steps}

---

##### Summary

This is a simulated response from the built-in mock engine.

**Prompt preview:**
> ${prompt_preview}...

##### Actions Taken

- [mock] Analyzed prompt
- [mock] Simulated processing
- [mock] Generated placeholder response

---

*Generated by built-in mock for dry-run testing.*
EOF

    echo "[ai] Mock response: ${response_file}" >> "${engine_log}"
    echo "dry-run: mock response generated"
    return 0
  fi

  local skip_flag=""
  [[ "${SKIP_GIT_CHECK}" -eq 1 ]] && skip_flag="--skip-git-repo-check "
  local selected_model="${ACTIVE_MODEL:-${MODEL:-}}"

  local cmd="codex exec --full-auto ${skip_flag}-C ${ROOT} -o ${response_file} - < ${prompt_file}"
  [[ -n "${selected_model}" ]] && cmd="codex exec --full-auto ${skip_flag}-C ${ROOT} --model ${selected_model} -o ${response_file} - < ${prompt_file}"

  if [[ "${TIMEOUT_SECONDS}" -gt 0 ]]; then
    set +e
    timeout "${TIMEOUT_SECONDS}" bash -lc "${cmd}" >> "${engine_log}" 2>&1
    local rc=$?
    set -e
    [[ "${rc}" -eq 124 ]] && echo "command timed out after ${TIMEOUT_SECONDS}s" >&2
    return "${rc}"
  fi

  eval "${cmd}" >> "${engine_log}" 2>&1
}
